# 자바와 객체지향
- - -
## 클래스 

>클래스 = 설계도
>
클래스를 사용하기 위해서는 인스턴스를 만들어주어야하며, 인스턴스를 만들고 사용하려면 인스턴스를 참조한느 변수가 반드시 필요하다.

- 인스턴스 선언 방법

	클래스명(참조타입) 변수명(참조변수) = new(new연산자) 클래스명() (생성자);

```java

	Book b = new Book();  // Book 이라는 Heap메모리에 만들고 인스턴스를 참조한다
/*  	(1) (2)  (3)  (4)

	(1) : 변수 b에 대한 래퍼런스 타입
	(2) : 참조변수
	(3) : new (new가 나오면 '인스턴스를 만드는거구나!')
	(4) : 생성자 ( 클래스이름() ) 
*/ 
```

위를 통해, new 연산자를 사용하면 메모리에 인스턴스가 생성된다는 점을 알 수 있다

new를 많이 사용할수록 메모리에 인스턴스가 많아지기 때문에 메모리부족 문제가 생길 수 있으며 프로그램이 죽을 수 있는 위험성이 존재한다

따라서 클래스 지향프로그래밍이 아닌 클래스의 인스턴스를 만든 후, 객체는 필요한 갯수만큼 만들어 사용하는 객체 지향 프로그래밍 하도록 고민해야한다

**ex. 자판기 클래스 예시**

main 메소드가 없는 클래스는 실행되지 않기 떄문에 VendingMachineMain이라는 클래스에서 main 메소드를 작성하고 VendingMachine 인스턴스를 생성하였다

VendingMachine 클래스를 사용하기 위해 VendingMachineMain이라는 클래스를 추가로 만들었다

~~~java
public class VendingMachine {
	// field - 자판기가 가지는 것들 (동전통, 상품케이스)
	// 생성자 
	// method
}
~~~

	

~~~java
public class VendingMachine {
	public static void main(String[] args){
		VendingMachine vm1 = new VendingMachine();
		VendingMachine vm2 = new VendingMachine();
		}
}
~~~


---
## 객체지향 프로그래밍

> 객체지향의 핵심은 "메시징"이다
> 
> 훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다
> 모듈이 어떻게 커뮤니케이션하는가에 달려있다
> 
> -앤런 커티스-


앤런 커티스 케이는 객체 지향의 핵심은 "메시징"이라고 말하였다

어떤 객체가 다른 객체에 메소드를 호출하는 것이 메시징이라고 하며, 즉 *"객체지향 프로그래밍을 한다"* 라는 것은 
메소드가 언제 호출되고, 어떻게 호출될까? 메소드의 이름은 어떻게 지어야할까? 어떻게 호출해야 할까? 를 고민하여 프로그램을 설계하는 것이라고 말할 수 있다





#### 좋은 객체 , 나쁜 객체

> 좋은 객체는 응집도는 높고 결합도(Coupling)는 낮다

응집도가 높다는게 무슨말인가? 객체와 관련된 기능을 잘 모아서 가지고 있는 것을 응집도가 높다고 이야기한다
예를 들면, 건조기가 건조기의 기능들을 잘 수행하고 있다면 응집도가 높고 책임을 잘 하고 있는것이라고 말할 수 있다

결합도가 낮다라는 말은 무슨 뜻일까? 컴퓨터를 샀는데 부가적인 장비가 있어야만 컴퓨터가 동작한다면 컴퓨터 사용성이 떨어질 것이다
즉, 사용성을 높이기 위해서는 사용이 편리해지도록 결합도가 낮아야한다

**결론적으로, 좋은 객체를 만들려면 관련된 기능을 잘모아서 가지고 있어야하고 객체와 객체간에는 결합도는 낮춰야한다!**

---
#### 객체의 역할, 책임 그리고 협력 관점에서 본 좋은 객체, 나쁜 객체

> **좋은 객체**란?
> 역할과 책임에 충실하면서 다른 객체와 잘 협력하여 동작하는 객체

> 반대로 **나쁜 객체**란? 여러가지 역할을 한 가지 객체에 부여하거나, 이름과는 맞지 않는 속성과 기능을 가지도록 하거나 제대로 동작하지 않는 객체


객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다. 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다

따라서 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 자율적인 객체는 자율적인 책임을 가진다

예를 들자면, '세탁기는 세탁을 잘해야하고 세탁과 관련된 기능을 잘 가지고 있어야한다'라고 생각할 수 있다




### 캡슐화 
>관련된 것을 잘 모아서 가지고 있는 것

관련된 것을 잘 모아서 가지고 있을수록 응집도가 높다고 표현한다

### 상속

'XX는 XX다'또는 'XX은 XX의 종류 중 하나다' 라고 표현할 수 있다면 이것은 상속관계라고 말할 수 있다 ( is a 관계 혹은 kind of 관계라고 말하기도 함)

_ex) 노트북은 컴퓨터다 , 트럭은 자동차의 한 종류이다_

> 상속 = 일반화 + 확장

상속이란 일반화와 확장이라는 개념을 합한 것이라고 생각할 수 있다

일반화는 자식클래스들을 부모클래스로 부를 것이라고 말할 수 있으며, '일반화시킨다'라고 한다면 여러 종류의 객체를 하나의 이름으로 부를 수 있는 것을 의미한다

부모클래스를 상속받은 속성과 기능은 자식클래스가 물려받아 사용할 수 있다

아무것도 상속받지 않으면 자동으로 java.lang.Object를 상속받는다. 따라서, 모든 클래스는 Object의 자손이다



**_주의!_**

상속은 굉장히 강한 결합이기때문에 상속은 반드시 써야할 때만 쓰고 되도록 사용하지 않는게 좋다.

결합도가 높으면 잘못 상속받았을때 타격이 크고 재사용하기가 힘들기 때문이다.

위애서 설명했듯이 좋은 객체가 되려면 결합도는 낮추고, 응집도는 높이는 것이 좋다는 점을 잊지말자!


- 상속 선언 방법

~~~java
[접근제한자] [ abstract | final ] class 클래스명 extends 부모클래스명 {
    
    //클래스 블록
} 
~~~


### 다형성과 오버로딩
- 다형성
> 메서드를 같은 이름으로 사용하는 것

- 메서드 오버로딩
> 메서드의 이름은 같지만 받아드리는 매개변수의 갯수나 타입이 다른 함수를 정의하는 것을 의미


Ex. System.out.println( .. )

우리가 자주 사용한는 입출력 System.out.println( .. )이 그 예시이다.

정수를 출력하는 메서드 이름은 printlnt(), 문자열을 출력하는 메서드이름은 printStrint()처럼 어떤 타입을 출력하느냐에 따라 
메서드 이름이 달라진다면 사용자는 외워야할 메서드 수가 많아 힘들어 할 것이다.

숫자를 출력하고 줄바꿈을 하든 문자를 출력하고 줄 바꿈을 하든 메소드 이름을 다르게 지을 필요가 없기때문에
사용자입장에서 편리함을 주는 다형성은 객체지향의 중요한 요소이다.

**주의!** *리턴값만을 다르게 갖는 오버로딩은 작성할 수 없다*

- 메서드 오버라이딩
> 상의 클래스의 메서드를 하위 클래스가 재정의 하는것

메서드 이름은 물론 파라미터의 갯수나 타입도 동일해야하며, 주로 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용된다.


### 추상화
>중요한것은 남기고, 불필요한 것은 제거한다

물건을 바라보는 관점에 따라 중요하다고 생각하는 부분이 다르기 때문에 추상화는 바라보는 관점에 따라 달라진다


프로그램 만들때 비지니스 영역 (도메인 영역)에 맞도록 추상화 해야한다
우리에게 필요한 객체의 속성만 가지도록 하고, 기능도 필요한 것만 가지도록 한다.

